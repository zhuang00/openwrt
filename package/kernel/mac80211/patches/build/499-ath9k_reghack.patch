--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@ -224,15 +224,8 @@
 	.alpha2 =  "00",
 	.reg_rules = {
 		/* IEEE 802.11b/g, channels 1..11 */
-		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
-		/* IEEE 802.11b/g, channels 12..13. */
-		REG_RULE(2467-10, 2472+10, 20, 6, 20,
-			NL80211_RRF_NO_IR | NL80211_RRF_AUTO_BW),
-		/* IEEE 802.11 channel 14 - Only JP enables
-		 * this and for 802.11b only */
-		REG_RULE(2484-10, 2484+10, 20, 6, 20,
-			NL80211_RRF_NO_IR |
-			NL80211_RRF_NO_OFDM),
+		REG_RULE(2192-10, 2472+10, 40, 6, 30, 0),
+		REG_RULE(2484-10, 2484+10, 40, 6, 30, 0),
 		/* IEEE 802.11a, channel 36..48 */
 		REG_RULE(5180-10, 5240+10, 80, 6, 20,
                         NL80211_RRF_NO_IR |
@@ -3732,13 +3725,6 @@
 
 	if (!regdom_changes(rd->alpha2))
 		return -EALREADY;
-
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
 
 	if (!user_request->intersect) {
 		reset_regdomains(false, rd);
@@ -3770,12 +3756,6 @@
 	if (!regdom_changes(rd->alpha2))
 		return -EALREADY;
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
 
 	request_wiphy = wiphy_idx_to_wiphy(driver_request->wiphy_idx);
 	if (!request_wiphy)
@@ -3829,12 +3809,6 @@
 	 * and the pending request came in from a country IE
 	 */
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
 
 	request_wiphy = wiphy_idx_to_wiphy(country_ie_request->wiphy_idx);
 	if (!request_wiphy)
@@ -3938,11 +3912,6 @@
 		 "wiphy should have REGULATORY_WIPHY_SELF_MANAGED\n"))
 		return -EPERM;
 
-	if (WARN(!is_valid_rd(rd), "Invalid regulatory domain detected\n")) {
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
- 
 	regd = reg_copy_regd(rd);
 	if (IS_ERR(regd))
      return PTR_ERR(regd);
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -80,6 +80,7 @@
 		return 0; /* not supported */
 	switch (band) {
 	case NL80211_BAND_2GHZ:
+		chan = (int)(char)chan;
 		if (chan == 14)
 			return MHZ_TO_KHZ(2484);
 		else if (chan < 14)
@@ -1662,7 +1663,14 @@
 		if (chandef->width != NL80211_CHAN_WIDTH_20_NOHT)
 			return false;
 
-		*op_class = 82; /* channel 14 */
+		if (chandef->width == NL80211_CHAN_WIDTH_40) {
+			if (freq > chandef->chan->center_freq)
+				*op_class = 83; /* HT40+ */
+			else
+				*op_class = 84; /* HT40- */
+		} else {
+			*op_class = 81;
+		}
 		return true;
 	}
 
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -60,6 +60,9 @@
 	power = ieee80211_chandef_max_power(&chanctx_conf->def);
 	rcu_read_unlock();
 
+	printk(KERN_DEBUG "ieee80211_recalc_txpower chandef_max_power=%d user_power_level=%d ap_pwoer_level=%d vif.vss_conf.txpower=%d", power, sdata->user_power_level, sdata->ap_power_level, sdata->vif.bss_conf.txpower);
+
+	power = sdata->user_power_level;
 	if (sdata->user_power_level != IEEE80211_UNSET_POWER_LEVEL)
 		power = min(power, sdata->user_power_level);
 
